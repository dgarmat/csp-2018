---
title: "Untitled"
author: "Emile Latour"
date: "February 5, 2018"
output: github_document
---

```{r setup, include=FALSE}

#### Global chunk options -----------------------------

knitr::opts_chunk$set(
  eval       = TRUE,    # whether to run code in code chunk
  include    = TRUE,    # whether to include the chunk output
  echo       = TRUE,    # Whether to show code chunk in final output
  error      = TRUE,    # whether to display error messages
  message    = FALSE,   # whether to preserve messages
  warning    = FALSE,   # whether to preserve warnings
  comment    = NA,      # a character string to append at start
                        # of each line of results in final document
  tidy       = FALSE   # whether to tidy code chunks for display
  
)


#### Other options --------------------------------

## Scientific notation ---------------

# Find out what it is set to
# getOption("scipen")

# Turn off scientific notation
options(scipen = 999)


## define format ----------------
# If you don't define format here, you'll need put `format = "html"` in 
# every kable function.

options(knitr.table.format = "html")  # use this option when knitting html
# options(knitr.table.format = "latex")  # use this option when knitting pdf


#### Set random seed ----------------------------

seed_for_imp <- 8675309
set.seed(seed_for_imp)


#### Packages --------------------------------------
# This is where we load in all the packages we plan to use

## Define the repository for packages ----------------
options(repos = c(CRAN = "http://cran.rstudio.com"))

# universally useful packages
if (!require("pacman")) install.packages("pacman")
if (!require("devtools")) install.packages("devtools")

# github packages
if (!require("janitor")) devtools::install_github("sfirke/janitor")
if (packageVersion("janitor") < "0.4.0.9000") {
  devtools::install_github("sfirke/janitor")
}
  
# Load the list of packages
pacman::p_load(
  Hmisc,         # contains many functions useful for data analysis
  psych,         # a general purpose toolbox
  tidyverse,     # packages ggplot2, tibble, tidyr, readr, purrr, and dplyr 
  forcats,       # functions for factors, forcats is an anagram for factors
  broom,         # functions tidy(), glance(), augment()
  magrittr,      # includes the %<>% assignment-pipe (%>% is loaded from dplyr)
  rlang,         # For use in tidyevaluation
  readxl,        # read in excel files
  writexl,       # write excel files, zero dependency
  xlsx,          # read, write, format Excel files
  janitor,       # for working with dirty data
  lubridate,     # for working with dates and times
  stringr,       # handy string operations
  tableone,      # Create Table 1 to Describe Baseline Characteristics
  DT,            # render R objects as HTML tables
  knitr,         # A General-Purpose Package for Dynamic Report Generation in R
  kableExtra,    # Enahced table functions
  ggthemes,      # Extra Themes, Scales and Geoms for 'ggplot2'
  scales,        # Scale Functions for Visualization
  visdat,        # Preliminary data visualisation
  naniar,        # structures, summaries, and visualisations for missing data
  here,          # Constructs paths to your project's files
  mice           # Multivariate Imputation by Chained Equations

  )


#### Other packages -----------------------------

#### Some resources ---------------------------

#### Themes and colors -------------------------------

#### Confirm directory --------------------------------

here::here()

```


# Simulate a data set

Due to the sensitive nature of electronic health record (EHR) data, in order to provide a data set for a reproducible example, I wrote code below to simulate a data set that can be used with the rest of the code in this example. The only similarities to the original data are the variable names and the data categories.

Note that the eligibility requirements for screening services are based on sex, age, and medical history. I do not simulate medical history and so the eligility here is based only on sex and age.

The proportions of screenings in the data were chosen to try to simulate some data that would make for interesting example with the rest of the code. The proportions of missingness are similar to the actual work that I presented in that I did a little bit of rounding before simulation.

Disclaimer: All the data in this example is simulated from the following code. Any similarities to the original data set or any other existing data is purely by chance alone.

```{r make-fake-data, results=FALSE}

#### Set the variable names --------------------------------

var_names <- c("study_id",
               "sex",
               "age_start",
               "primary_dept",
               "ethnic_cat",
               "lang_cat",
               "race_cat",
               "fpl_cat",
               "age_cat",
               "elig_cervical",
               "elig_breast",
               "elig_colon",
               "elig_colonoscopy",
               "elig_flexsig",
               "elig_fobt",
               "elig_bmi",
               "elig_flu",
               "elig_chlam",
               "elig_smoking",
               "elig_cholest",
               "dmap_cervical",
               "dmap_breast",
               "dmap_colon",
               "dmap_colonoscopy",
               "dmap_flexsig",
               "dmap_fobt",
               "dmap_bmi",
               "dmap_flu",
               "dmap_chlam",
               "dmap_smoking",
               "dmap_cholest",
               "ehr_cervical",
               "ehr_breast",
               "ehr_colon",
               "ehr_colonoscopy",
               "ehr_flexsig",
               "ehr_fobt",
               "ehr_bmi",
               "ehr_flu",
               "ehr_chlam",
               "ehr_smoking",
               "ehr_cholest"
)


#### Make an empty tibble --------------------------------

## Pre-set the number of rows for the data set ----------------

size <- 14000

## Create tibble with NA's ----------------

valdata <- tibble::as.tibble(matrix(NA, nrow = size, ncol = length(var_names)))
names(valdata) <- var_names


#### Make the demographic data --------------------------------

## Function to help make factor variables ----------------

make_factor <- function(levels, size, replace = TRUE, prob = NULL) { 
  
  if (is.null(prob)) { 
    
    factor(sample(levels, size, replace))
    
  } else {
      
    factor(sample(levels, size, replace, prob))
  }
}

## Make the demographic data ----------------
# Note that the proportions for the demographic categories are made up and
# decided upon by me. I intended for them to be similar in magnitude to the
# original study data, but different enough that they could not be compared to 
# or construed to be original values. Variables with percent missing are the 
# same ones as my previous work, but the percent missing is slightly different 
# with rounding.

# 3 group sizes for age groups
a <- floor(size / 3)
b <- a
c <- size - a - b

valdata %<>% 
  mutate(
    study_id = seq(1:size), 
    sex = make_factor(levels = c("F", "M"), 
                      size = size, 
                      prob = c(0.65, 0.35)), 
    age_start = c(sample(c(19:34), size = a, replace = TRUE), 
                  sample(c(35:50), size = b, replace = TRUE), 
                  sample(c(51:64), size = c, replace = TRUE)
    ), 
    age_start = sample(age_start, 
                       size = size, 
                       replace = FALSE), 
    age_cat = cut(age_start, 
                  breaks = c(19, 35, 51, 65), 
                  right = FALSE), 
    primary_dept = make_factor(levels = 
                                 stringr::str_pad(c(1:40), 3, pad = "0"), 
                               size = size), 
    ethnic_cat = make_factor(levels = 
                               c("Hispanic", "NH White", "NH Other", NA), 
                             size = size, 
                             prob = c(0.10, 0.70, 0.15, 0.05)), 
    lang_cat = make_factor(levels = c("English", "Spanish", "Other"), 
                           size = size, 
                           prob = c(0.85, 0.05, 0.10)), 
    race_cat = make_factor(
      levels = c("API", "AIAN", "Black", "White", "Multiple Races", NA), 
      size = size, 
      prob = c(0.05, 0.02, 0.10, 0.75, 0.01, 0.07)), 
    fpl_cat = make_factor(levels = c("<=138% FPL", ">138% FPL", NA), 
                          size = size, 
                          prob = c(0.75, 0.05, 0.20))
  )

# drop variabls no longer needed
rm(a, b, c)


#### Make the eligibility variables --------------------------------
# The original study paper outlined the criteria to be eligible for certain
# screening services. They tended to be based on sex, age, and medical history.
# I will not be generating variables for the relevant medical history for
# eligibility. For the purpose of this simulated data set, I will base
# eligibility only on sex and age.

# 1 = eligible
# 0 = not eligible

# Function to convert to factors 
make_factor2 <- function(var) {
  factor(var, levels = c("1", "0"))
}

valdata %<>% 
  mutate(
    elig_cervical = 
      ifelse(sex == "F" & age_start >= 19 & age_start <= 64, 1, 0), 
    elig_breast = 
      ifelse(sex == "F" & age_start >= 40, 1, 0), 
    elig_colon = 
      ifelse(age_start >= 50, 1, 0), 
    elig_colonoscopy = 
      ifelse(age_start >= 50, 1, 0), 
    elig_flexsig = 
      ifelse(age_start >= 50, 1, 0), 
    elig_fobt = 
      ifelse(age_start >= 50, 1, 0),  
    elig_bmi = 1, 
    elig_flu = 
      ifelse(age_start >= 50, 1, 0), 
    elig_chlam = 
      ifelse(sex == "F" & age_start >= 19 & age_start <= 24, 1, 0), 
    elig_smoking = 1, 
    elig_cholest = 
      ifelse(age_start >= 20, 1, 0)) %>% 
  mutate_at(.vars = vars(elig_cervical:elig_cholest), 
            .funs = funs(make_factor2))


#### Make factor screening variables --------------------------------
# A patient must be elgible to recieve a screening service. Those that are
# eligible based on the step above will be randomly assigned 1/0 (screened/not
# screened); those that are not elgible will be assigned 0 (not screened).

## Function to help make the screening data ----------------
# Split the data set into eligible and not eligible. Randomly assign
# screen/not-screened to those that are eligible. Not screened to those that are
# not elgibile. Combine the split data sets.

# Returns a data frame / tibble.

make_screening <- function(df, 
                           elig_var, 
                           dmp_scr, 
                           ehr_scr, 
                           dmp_prob, 
                           ehr_prob) { 
  
  require(rlang)
  require(dplyr)
  
  elig_enq <- enquo(elig_var)
  dmp_enq <- enquo(dmp_scr)
  dmp_name <- quo_name(dmp_enq)
  ehr_enq <- enquo(ehr_scr)
  ehr_name <- quo_name(ehr_enq)
  
  num_elig <- df %>% 
    dplyr::filter(!! elig_enq == 1) %>% 
    dplyr::count(!! elig_enq) %>% 
    dplyr::pull()
  
  num_not_elig <- df %>% 
    dplyr::filter(!! elig_enq != 1) %>% 
    dplyr::count(!! elig_enq) %>% 
    dplyr::pull()
  
  df_elig <- df %>% 
    dplyr::filter(!! elig_enq == 1) %>% 
    mutate(
      !! dmp_name := rbinom(n = num_elig, size = 1, prob = dmp_prob), 
      !! ehr_name := rbinom(n = num_elig, size = 1, prob = ehr_prob), 
      !! dmp_name := factor(!! dmp_enq, levels = c(1, 0)), 
      !! ehr_name := factor(!! ehr_enq, levels = c(1, 0))
    )
  
  df_not_elig <- df %>% 
    dplyr::filter(!! elig_enq != 1) %>% 
    mutate(
      !! dmp_name := 0, 
      !! ehr_name := 0, 
      !! dmp_name := factor(!! dmp_enq, levels = c(1, 0)), 
      !! ehr_name := factor(!! ehr_enq, levels = c(1, 0))
    )
    
  df_elig %>% 
    dplyr::bind_rows(., df_not_elig) %>% 
    dplyr::arrange(., study_id)

}

## Make the screenings values ----------------

valdata <- make_screening(df = valdata, 
                          elig_var = elig_cervical, 
                          dmp_scr = dmap_cervical, 
                          ehr_scr = ehr_cervical, 
                          dmp_prob = 0.30, 
                          ehr_prob = 0.30)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_breast, 
                          dmp_scr = dmap_breast, 
                          ehr_scr = ehr_breast, 
                          dmp_prob = 0.40, 
                          ehr_prob = 0.40)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_colon, 
                          dmp_scr = dmap_colon, 
                          ehr_scr = ehr_colon, 
                          dmp_prob = 0.30, 
                          ehr_prob = 0.30)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_colonoscopy, 
                          dmp_scr = dmap_colonoscopy, 
                          ehr_scr = ehr_colonoscopy, 
                          dmp_prob = 0.10, 
                          ehr_prob = 0.10)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_flexsig, 
                          dmp_scr = dmap_flexsig, 
                          ehr_scr = ehr_flexsig, 
                          dmp_prob = 0.05, 
                          ehr_prob = 0.05)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_fobt, 
                          dmp_scr = dmap_fobt, 
                          ehr_scr = ehr_fobt, 
                          dmp_prob = 0.15, 
                          ehr_prob = 0.30)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_bmi, 
                          dmp_scr = dmap_bmi, 
                          ehr_scr = ehr_bmi, 
                          dmp_prob = 0.05, 
                          ehr_prob = 0.85)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_flu, 
                          dmp_scr = dmap_flu, 
                          ehr_scr = ehr_flu, 
                          dmp_prob = 0.35, 
                          ehr_prob = 0.40)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_chlam, 
                          dmp_scr = dmap_chlam, 
                          ehr_scr = ehr_chlam, 
                          dmp_prob = 0.50, 
                          ehr_prob = 0.40)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_smoking, 
                          dmp_scr = dmap_smoking, 
                          ehr_scr = ehr_smoking, 
                          dmp_prob = 0.05, 
                          ehr_prob = 0.95)

valdata <- make_screening(df = valdata, 
                          elig_var = elig_cholest, 
                          dmp_scr = dmap_cholest, 
                          ehr_scr = ehr_cholest, 
                          dmp_prob = 0.40, 
                          ehr_prob = 0.40)


#### Remove what's no longer needed --------------------------------

rm(make_factor, make_factor2, make_screening, size, var_names)

```

TODO -- Change the name of the data set everywhere else.
TODO -- test the user functions


# EDA / explore missingness


TODO -- add this stuff later

# Imputation

## Some set up

Here I want to defined variables for the number of imputations and the number of iterations. 

```{r}
imp_num <- 30  # number of imputations, dflt = 5
# iter_num <- 20  # number of interations, dflt = 5
iter_num <- 1  # number of interations, dflt = 5

```


## Quick predictor matrix

According to van Burren the `predictormatrix` function is useful for dealing with data sets with large number of variables. 

Only show the matrix below for those records with > 1 rows or columns

```{r}
predGuess <- valdata %>% 
  mice::quickpred(.)

predGuess[rowSums(predGuess) > 0, colSums(predGuess) > 0] %>% 
  kable()

```


# Variables to include

A list of variables was ordered and curated by John Heintzman.

```{r}

varNames <- 
  c("StudyID", "sex", "age_start", # "FPL_PERCENTAGE", 
    "PrimaryDept", "ethnic.cat", "lang.cat", "race.cat", 
    "fpl.cat", "age.cat", "ELIG_cervical", "ELIG_breast", 
    "ELIG_colon", "ELIG_colonoscopy", "ELIG_flexsig", 
    "ELIG_FOBT", "ELIG_BMI", "ELIG_Flu", "ELIG_chlam", 
    "ELIG_smoking", "ELIG_cholest", "DMAP_cervical", 
    "DMAP_breast", "DMAP_colon", "DMAP_colonoscopy", 
    "DMAP_flexsig", "DMAP_FOBT", "DMAP_BMI", "DMAP_Flu", 
    "DMAP_chlam", "DMAP_smoking", "DMAP_cholest", "EHR_cervical", 
    "EHR_breast", "EHR_colon", "EHR_colonoscopy", "EHR_FlexSig", 
    "EHR_FOBT", "EHR_BMI", "EHR_Weight", "EHR_Flu", "EHR_chlam", 
    "EHR_smoking", "EHR_cholest")

# JH_list <- 
#   c("fpl.cat", "race.cat", "ethnic.cat", "lang.cat", "age_start", "sex", 
#     "PrimaryDept", "EHR_cervical", "EHR_breast", "EHR_colon", 
#     "EHR_colonoscopy", "DMAP_breast", "DMAP_colonoscopy", "EHR_cholest", 
#     "DMAP_cholest", "CholestScreen_elig", "EHR_FlexSig", "EHR_FOBT", 
#     "EHR_BMI", "EHR_Weight", "EHR_Flu", "EHR_chlam", "EHR_smoke", 
#     "DMAP_cervical", "DMAP_colon", "DMAP_flexsig", "DMAP_FOBT", "DMAP_BMI", 
#     "DMAP_Flu", "DMAP_chlam", "CervicalScreen_elig", "BreastScreen_elig", 
#     "ColonScreen_elig", "BMIScreen_elig", "FluVac_elig", "ChlamydScreen_elig", 
#     "TobaccoScreen_elig"
#     )

JH_list <- 
  c("fpl.cat", "race.cat", "ethnic.cat", "lang.cat", "age_start", "sex", 
    "PrimaryDept", "EHR_cervical", "EHR_breast", "EHR_colon", 
    "EHR_colonoscopy", "DMAP_breast", "DMAP_colonoscopy", "EHR_cholest", 
    "DMAP_cholest", "ELIG_cholest", "EHR_FlexSig", "EHR_FOBT", 
    "EHR_BMI", "EHR_Weight", "EHR_Flu", "EHR_chlam", "EHR_smoking", 
    "DMAP_cervical", "DMAP_colon", "DMAP_flexsig", "DMAP_FOBT", "DMAP_BMI", 
    "DMAP_Flu", "DMAP_chlam", "ELIG_cervical", "ELIG_breast", 
    "ELIG_colon", "ELIG_BMI", "ELIG_Flu", "ELIG_chlam", 
    "ELIG_smoking"
    )
# Remove
# "StudyID", "FPL_PERCENTAGE", "age.cat", "DMAP_smoking"

vars_to_include <- varNames[(varNames %in% JH_list)]

# varNames[!(varNames %in% JH_list)]

pred <- predGuess
pred[, ] <- 0
pred[, vars_to_include] <- 1
diag(pred) <- 0
# head(pred)
dim(pred)
head(pred)
```

# Make the visiting scheme

Pretty sure that this doesn't do anything.

```{r}
miOrder <- vars_to_include %>% 
  match(., JH_list) %>% 
  as.numeric(.)

comboList <- data.frame(vars_to_include, JH_list) %>% 
  cbind(., miOrder)
  
comboList %>% 
  kable(.)

```



## Visting sequence

This tells `mice` the order to impute the missing variables. I looked at high to low and low to high. Didn't seem to make a difference. van Buuren says that it would only really matter with longitudinal studies.

`init$visitSequence` give the varaibles to be imputed and their column positions.

```{r}
init <- mice::mice(cardiac, maxit = 0)
meth <- init$method
predM <- init$predictorMatrix
# print(ini)
 

init$visitSequence
# ethnic.cat   race.cat    fpl.cat 
#          5          7          8 
```


### Define the order for visiting

FPL -> Race -> Ethnicity

```{r}
visit_order <- c(init$visitSequence[["fpl.cat"]], 
                 init$visitSequence[["race.cat"]], 
                 init$visitSequence[["ethnic.cat"]])
```

## Specify the methods for imputing the missing values

__FPL__ -- logistic regression (`logreg`), for factor with 2 levels.

__Race__ -- Multinomial logit regression (`polyreg`), factor with > 2 levels.

__Ethnicity__ -- Multinomial logit regression (`polyreg`), factor with > 2 levels.

```{r}
meth[c("ethnic.cat")] <- "polyreg"
meth[c("race.cat")] <- "polyreg"
meth[c("fpl.cat")] <- "logreg"
meth
```

## Predictor matrices



### Full list 

```{r}
pred <- predM
pred[, ] <- 0
pred[, vars_to_include] <- 1
diag(pred) <- 0

head(pred[, 1:10], n = 10)

```

# Imputations (FPL, Race, and Ethnicity)

## Full list (41 vars)

```{r, cache=FALSE}
system.time(
imp_full <- 
  mice::mice(data = cardiac, 
             m = imp_num,  # number of imputations, dflt = 5
             method = meth,  # specify the method
             predictorMatrix = pred, 
             visitSequence = visit_order, 
             seed = seed_for_imp, 
             maxit = iter_num,  # number of interations, dflt = 5
             print = FALSE
             )
)
 #   user  system elapsed 
 # 753.92   10.39  765.00 

# with 20 imputations
#    user  system elapsed 
# 3782.48   25.14 3821.28
```

### Plot of convergence

```{r}
plot(imp_full, c("ethnic.cat", "race.cat", "fpl.cat"))
```


# Look at the imputed data sets

```{r}

mylist <- list() #create an empty list

for (i in 1:imp_full$m) {
  
  mylist[[i]] <- mice::complete(imp_full, i)
  
}

mylist[[1]]


output <- tibble::enframe(mylist, name = "imp", value = "data") %>% 
  tidyr::unnest()

# This would do the same thing, maybe faster, but the above has the added 
# benefit of easily adding the number of the imputation so that I can track 
# things. Either way, I chose the one above as my preference.
# df <- do.call(rbind, mylist)
# df

# Should be 393,030 rows = 30 sets X 13101 rows per set
dplyr::glimpse(output)
head(output)
tail(output)

```


```{r}
make_cardiac_long <- function(df) { 
  
  # Reshape ELIG, DMAP, and EHR
  df_long <- df %>% 
    tidyr::gather(data = ., 
                  key = "vars", 
                  value = "value", 
                  ELIG_cervical:EHR_cholest) %>% 
    tidyr::separate(col = vars, 
                    into = c("EHR_DMAP_ELIG", "proc"), 
                    sep = "_", 
                    remove = TRUE) %>% 
    dplyr::mutate(proc = case_when(
      proc == "BMI" ~ "bmi", 
      proc == "FlexSig" ~ "flexsig", 
      proc == "FOBT" ~ "fobt", 
      proc == "Weight" ~ "weight", 
      TRUE ~ proc
    )) %>% 
    tidyr::spread(data = ., 
                  key = EHR_DMAP_ELIG, 
                  value = value)
  
  # Gather the categories
  df_long %<>% 
    tidyr::gather(data = ., 
                  key = "cat", 
                  value = "level", 
                  sex, ethnic.cat:age.cat) %>% 
    mutate(cat = case_when(
      cat == "age.cat" ~ "age", 
      cat == "ethnic.cat" ~ "ethnicity", 
      cat == "fpl.cat" ~ "fpl", 
      cat == "lang.cat" ~ "language", 
      cat == "race.cat" ~ "race", 
      TRUE ~ cat
    ))
  
  
  # Pick one category and dummy the category and the levels
  # And bind the all back to the long data
  df_long %<>% 
    dplyr::filter(cat == "sex") %>% 
    mutate(cat = "all", 
           level = "all") %>% 
    dplyr::bind_rows(., df_long)
  
  df_long %>%
    dplyr::select(imp, 
                  StudyID,
                  age_start,
                  PrimaryDept,
                  proc, 
                  cat,
                  level, 
                  ELIG, 
                  EHR, 
                  DMAP
                  )
  
  }
```


```{r}


df <- make_cardiac_long(df = output)

df

df %>% 
  group_by(cat) %>% 
  summarise(
    n = n(), 
    ELIG = sum(as.numeric(ELIG), na.rm = TRUE), 
    EHR = sum(as.numeric(EHR), na.rm = TRUE), 
    DMAP = sum(as.numeric(DMAP), na.rm = TRUE), 
    id = sum(as.numeric(StudyID), na.rm = TRUE), 
    age = sum(age_start, na.rm = TRUE)
  )



```


```{r}
df_nested <- df %>% 
  group_by(proc, cat, level, imp) %>% 
  nest()



df_nested
df_nested$data[[1]]
head(df_nested$data[[1]])
tail(df_nested$data[[1]])



```



```{r, warning=FALSE}

foo <- df_nested %>% 
  mutate(Q = purrr::map(.x = data, .f = calc_stats_p), 
         U = purrr::map(.x = data, .f = calc_stats_se))

foo
foo$data[[1]]

bar <- foo %>% 
  tidyr::unnest(Q, U) %>% 
  dplyr::rename(Q = Q, 
                U = Q1) %>% 
  dplyr::select(-stat1) %>% 
  dplyr::filter(! (stat %in% c("EHR.t", "DMAP.t", "Combo.t"))) %>% 
  mutate_at(.vars = vars(Q, U), .funs = funs(as.numeric))


bar <- bar %>% 
  group_by(proc, cat, level, stat) %>% 
  nest()

bar$data[[1]]

bar <- bar %>% 
  mutate(pooled = purrr::map(.x = data, .f = mi_pool))

baz <- bar %>% 
  unnest(pooled)


```

```{r}

baz %>% 
  dplyr::select(proc:stat, qbar) %>% 
  tidyr::spread(., key = stat, value = qbar)

```

```{r}

baz %>% 
  group_by(proc, cat, level) %>% 
  count()


12 * 19


length(unique(baz$level))
length(unique(baz$cat))
length(unique(baz$proc))

```

